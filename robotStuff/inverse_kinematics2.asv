% ************** MATLAB "M" function (jim Patton) *************
% determine angles & derivatives endpt positions and their derivatives
% AFTER SIMPLIFYING USING MATHEMATICA (see Patton's notes 9/2/99)
% Syntax: [phi]=inverse_kinematics2(rho,lengths)
%
% TEST WITH:
% [rho,q,phi,t1]= get_trajectory('pt2pt.txd',10*pi/180,0.12,[-.01 .3]); figure(1); clf; subplot(2,1,1); plot(rho(:,2), rho(:,3),'.'); axis equal; title('positions');  phi_new=inverse_kinematics2(rho(:,2:7),L);     subplot(2,1,2); legend(plot(t1,phi(:,2:7),'.',  t1,phi_new,'o'),'1','2','3','4','5','6','1','2','3','4','5','6');
% The structure of the model is based on the following :
%
%            ^ y
%            |
%                                                     phi2  `
%            o                                     o       `
%             \                                     \     `                
%             (L2)  q2                              (L2) `                      
%               \                                     \ `               
%                o ` ` ` ` `                          o     
%               /                                    /           
%             (L1)   q1                            (L1)    phi1        
%             /                                    / 
%          __o___` ` ` ` ` `                    __o___` ` ` ` ` `  
%          \\\\\\\                              \\\\\\\                 ->x
% 
% INPUTS:     rho         endpoint postions, velocities, and accelerations
%             lengths     segment lengths [L1 L2]
% OUTPUTS:    phi         joint angular postions, velocities, and accelerations
%             q           angular postions, velocities, and accelerations
% VERSIONS:   9/2/99     INITIATED by Patton from inverse_kinematics.m
%~~~~~~~~~~~~~~~~~~~~~~ Begin Program: ~~~~~~~~~~~~~~~~~~~~~~~~~~

function [phi,q]=inverse_kinematics2(rho,lengths)

%___ SETUP ___
[rows,cols]=size(rho); if cols==1, rho=rho'; end        % make it a row vect
[rows,cols]=size(rho);
L1=lengths(1);    L2=lengths(2);

for i=1:rows,
  x=rho(i,1);         y=rho(i,2);
  xDot=rho(i,3);      yDot=rho(i,4);
  xDotDot=rho(i,5);   yDotDot=rho(i,6);

  %__ INV KIN __
  phi1=                                                               ...
     -atan(2*L1*L2*sqrt(1 - power(-power(L1,2) - power(L2,2) +        ...
      power(x,2) + power(y,2),2)/(4*power(L1,2)*power(L2,2)))/        ...
      (power(L1,2) - power(L2,2) + power(x,2) + power(y,2))) +        ...
      atan2(y,x);
      
      
-1/L1*(-ydot*y*L2^2+ydot*y*L1^2+xdot*y*L1*L2*(-(L2^2+2*L1*L2+L1^2-y^2-x^2)*(L2^2-2*L1*L2+L1^2-y^2-x^2)/L1^2/L2^2)^(1/2)-ydot*x*L1*L2*(-(L2^2+2*L1*L2+L1^2-y^2-x^2)*(L2^2-2*L1*L2+L1^2-y^2-x^2)/L1^2/L2^2)^(1/2)+xdot*x*L1^2-xdot*x*L2^2-xdot*x*y^2-ydot*y*x^2-xdot*x^3-ydot*y^3)/(x^2+y^2)/(-(L2^2+2*L1*L2+L1^2-y^2-x^2)*(L2^2-2*L1*L2+L1^2-y^2-x^2)/L1^2/L2^2)^(1/2)/L2
 
  phi1dot=                                                            ...                               
   (-(y*xDot) + x*yDot)/                                              ...
    (power(x,2) + power(y,2)) +                                       ...
   (-power(L1,2) + power(L2,2) + power(x,2) + power(y,2))*            ...
     (x*xDot + y*yDot)/                                               ...
     (L1*L2*(power(x,2) + power(y,2))*                                ...
    sqrt((-power(L1,4) + 2*power(L1,2)*power(L2,2) - power(L2,4) +    ...
          2*power(L1,2)*power(x,2) + 2*power(L2,2)*power(x,2) -       ...
          power(x,4) + 2*power(L1,2)*power(y,2) +                     ...
          2*power(L2,2)*power(y,2) - 2*power(x,2)*power(y,2) -        ...
          power(y,4))/(power(L1,2)*power(L2,2))));
          
  phi1dotdot=                                                         ...
   2*(y*xDot - x*yDot)*                                               ...
     (x*xDot + y*yDot)/                                               ...
    power(power(x,2) + power(y,2),2) +                                ...
   2*power(-power(L1,2) + power(L2,2) + power(x,2) + power(y,2),2)*   ...
     power(x*xDot + y*yDot,2)/                                        ...
    (L1*L2*power(power(x,2) + power(y,2),2)*                          ...
      (power(L1,2) - power(L2,2) + power(x,2) + power(y,2))*          ...
      sqrt((-power(L1,4) + 2*power(L1,2)*power(L2,2) - power(L2,4) +  ...
          2*power(L1,2)*power(x,2) + 2*power(L2,2)*power(x,2) -       ...
          power(x,4) + 2*power(L1,2)*power(y,2) +                     ...
          2*power(L2,2)*power(y,2) - 2*power(x,2)*power(y,2) -        ...
          power(y,4))/(power(L1,2)*power(L2,2)))) +                   ...
   (-(y*xDotDot) + x*yDotDot)/                                        ...
    (power(x,2) + power(y,2)) -                                       ...
   power(power(L1,2) - power(L2,2) + power(x,2) + power(y,2),2)*      ...
     (-(power(-power(L1,2) - power(L2,2) + power(x,2) + power(y,2),   ... 
            2)*power(x*xDot + y*yDot,                                 ...
            2))/                                                      ...
        (2*power(L1,3)*power(L2,3)*                                   ...
          (power(L1,2) - power(L2,2) + power(x,2) + power(y,2))*      ...
          power(1 - power(-power(L1,2) - power(L2,2) + power(x,2) +   ...
               power(y,2),2)/(4*power(L1,2)*power(L2,2)),3/2)) +      ...
       4*(-power(L1,2) - power(L2,2) + power(x,2) + power(y,2))*      ...
         power(x*xDot + y*yDot,2)/                                    ...
        (L1*L2*power(power(L1,2) - power(L2,2) + power(x,2) +         ...
            power(y,2),2)*sqrt(1 -                                    ...
            power(-power(L1,2) - power(L2,2) + power(x,2) +           ...
               power(y,2),2)/(4*power(L1,2)*power(L2,2)))) -          ...
       2*power(x*xDot + y*yDot,2)/                                    ...
        (L1*L2*(power(L1,2) - power(L2,2) + power(x,2) +              ...
            power(y,2))*sqrt(1 -                                      ...
            power(-power(L1,2) - power(L2,2) + power(x,2) +           ...
               power(y,2),2)/(4*power(L1,2)*power(L2,2)))) +          ...
       16*L1*L2*sqrt(1 - power(-power(L1,2) - power(L2,2) +           ...
              power(x,2) + power(y,2),2)/(4*power(L1,2)*power(L2,2))  ...
           )*power(x*xDot + y*yDot,2)/                                ...
        power(power(L1,2) - power(L2,2) + power(x,2) + power(y,2),3)  ...
         - (-power(L1,2) - power(L2,2) + power(x,2) + power(y,2))*    ...
         (power(xDot,2) + power(yDot,2) +                             ...
           x*xDotDot + y*yDotDot)/                                    ...
        (L1*L2*(power(L1,2) - power(L2,2) + power(x,2) +              ...
            power(y,2))*sqrt(1 -                                      ...
            power(-power(L1,2) - power(L2,2) + power(x,2) +           ...
               power(y,2),2)/(4*power(L1,2)*power(L2,2)))) -          ...
       4*L1*L2*sqrt(1 - power(-power(L1,2) - power(L2,2) +            ...
              power(x,2) + power(y,2),2)/(4*power(L1,2)*power(L2,2))  ...
           )*(power(xDot,2) +                                         ...
           power(yDot,2) + x*xDotDot +                                ...
           y*yDotDot)/                                                ...
        power(power(L1,2) - power(L2,2) + power(x,2) + power(y,2),2)  ...
       )/(4*power(L1,2)*(power(x,2) + power(y,2)));

  phi2=                                                               ...
   acos((-power(L1,2) - power(L2,2) + power(x,2) + power(y,2))/       ...
    (2*L1*L2));

  phi2dot=                                                            ...
  -((x*xDot + y*yDot)/                                                ...
     (L1*L2*sqrt(1 - power(-power(L1,2) - power(L2,2) + power(x,2) +  ...
            power(y,2),2)/(4*power(L1,2)*power(L2,2)))));

  phi2dotdot=                                                         ...
    -((-power(L1,2) - power(L2,2) + power(x,2) + power(y,2))*         ...
       power(x*xDot + y*yDot,2))/                                     ...
    (2*power(L1,3)*power(L2,3)*                                       ...
      power(1 - power(-power(L1,2) - power(L2,2) + power(x,2) +       ...
           power(y,2),2)/(4*power(L1,2)*power(L2,2)),3/2)) -          ...
    (power(xDot,2) + power(yDot,2) +                                  ...
      x*xDotDot + y*yDotDot)/                                         ...
     (L1*L2*sqrt(1 - power(-power(L1,2) - power(L2,2) + power(x,2) +  ...
     power(y,2),2)/(4*power(L1,2)*power(L2,2))));                      

  phi(i,:)=[phi1 phi2 phi1dot phi2dot phi1dotdot phi2dotdot]; % put into 1 vect
  
end % END for i

q=[phi(:,1), phi(:,2)+phi(:,1), phi(:,3), phi(:,4)+phi(:,3), phi(:,5), phi(:,6)+phi(:,5)];

return